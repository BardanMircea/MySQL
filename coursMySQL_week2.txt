-- Créer une base de données : bibliotheque



-- créer la table abonne   
--     - id_abonne (INT(11) AI - PK NOT NULL)
--     - prenom VARCHAR (255) NOT NULL


-- créer la table livre
--     - id_livre (INT(11) AI - PK NOT NULL)
--     - auteur VARCHAR (255) NOT NULL
--     - titre VARCHAR (255) NOT NULL
    

-- créer la table emprunt
--     - id_emprunt (INT(11) AI - PK NOT NULL)
--     - livre_id (INT (11) NOT NULL) RELATION avec id_livre de la table livre 
--     - abonne_id (INT (11) NOT NULL) RELATION avec id_abonne de la table abonne 
--     - date_sortie DATE NOT NULL
--     - date_rendue DATE NULL


-- INSERT INTO `abonne` (`id_abonne`, `prenom`) VALUES
-- (1, 'Guillaume'),
-- (2, 'Benoit'),
-- (3, 'Chloe'),
-- (4, 'Laura');


-- INSERT INTO `livre` (`id_livre`, `auteur`, `titre`) VALUES
-- (100, 'GUY DE MAUPASSANT', 'Une vie'),
-- (101, 'GUY DE MAUPASSANT', 'Bel-Ami '),
-- (102, 'HONORE DE BALZAC', 'Le père Goriot'),
-- (103, 'ALPHONSE DAUDET', 'Le Petit chose'),
-- (104, 'ALEXANDRE DUMAS', 'La Reine Margot'),
-- (105, 'ALEXANDRE DUMAS', 'Les Trois Mousquetaires');


-- CREATE TABLE `emprunt` (
--   `id_emprunt` int(11) NOT NULL,
--   `livre_id` int(11) NOT NULL,
--   `abonne_id` int(11) NOT NULL,
--   `date_sortie` date NOT NULL,
--   `date_rendue` date DEFAULT NULL
-- ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;





-- RAPPEL :
-- id_table ==> PK
-- table_id ==> FK

-- le principe de la bibliothèque est  qu'un abonné puisse       emprunter         des livres
--                     bdd                   table abonne       table emprunt     table livres


-- c'est quoi un emprunt ?
-- qqun ? abonne
-- qui emprunt
-- quoi ? livre

-- date_sortie : date à laquelle l'abonné a emprunté le livre
-- date_rendue peut être NULL car c'est  la date à laquelle l'abonné va rendre le livre 



--------------------------------------------------------------------------------------------------
-- Afficher l'id des livres qui n'ont été rendus

        -- IS NULL / IS NOT NULL


        SELECT livre_id 
        FROM emprunt 
        WHERE date_rendue IS NULL;

        -- +----------+
        -- | livre_id |
        -- +----------+
        -- |      105 |
        -- |      100 |
        -- +----------+


-- Afficher le titre des livres qui n'ont pas été rendus

    SELECT titre
    FROM livre 
    WHERE id_livre IN (100,105);



    SELECT titre FROM livre WHERE id_livre IN (
        SELECT livre_id FROM emprunt WHERE date_rendue IS NULL
    );


    -- +-------------------------+
    -- | titre                   |
    -- +-------------------------+
    -- | Une vie                 |
    -- | Les Trois Mousquetaires |
    -- +-------------------------+

    -- la requête d'imbrique permet d'intégrer des requêtes dans des requêtes (sur la même table ou sur des tables différentes (relations))
    -- la lecture des requêtes commençent par celle qui est la plus imbriquée 


    --------------------------------------------------------------------------------------------------------------------------------------

    -- Afficher l'id des abonnés qui n'ont pas rendus les livres

        SELECT abonne_id FROM emprunt WHERE date_rendue IS NULL;

        -- +-----------+
        -- | abonne_id |
        -- +-----------+
        -- |         3 |
        -- |         2 |
        -- +-----------+

    -- Afficher le prenom des abonnés qui n'ont pas rendus les livres


    SELECT prenom FROM abonne WHERE id_abonne IN(
        SELECT abonne_id FROM emprunt WHERE date_rendue IS NULL
    );


    -- +--------+
    -- | prenom |
    -- +--------+
    -- | Benoit |
    -- | Chloe  |
    -- +--------+


    -- Afficher l'id des livres que Chloé a emprunté


        -- Afficher l'id de Chloe
        SELECT id_abonne FROM abonne WHERE prenom = "chloe";

        -- +-----------+
        -- | id_abonne |
        -- +-----------+
        -- |         3 |
        -- +-----------+

        -- Afficher l'id des livres que l'abonne 3 a emprunté
        SELECT livre_id FROM emprunt WHERE abonne_id = 3;




                                       --  abonne_id = 3
        SELECT livre_id FROM emprunt WHERE abonne_id IN (
            SELECT id_abonne FROM abonne WHERE prenom = "chloe"
        );

        -- +----------+
        -- | livre_id |
        -- +----------+
        -- |      100 |
        -- |      105 |
        -- +----------+


-- Afficher les prénoms des abonnés qui ont rendus un livre le 11 décembre 2016




SELECT abonne_id FROM emprunt WHERE date_rendue = "2016-12-11";

    -- +-----------+
    -- | abonne_id |
    -- +-----------+
    -- |         1 |
    -- +-----------+


    SELECT prenom FROM abonne WHERE id_abonne IN(1);


    -- +-----------+
    -- | prenom    |
    -- +-----------+
    -- | Guillaume |
    -- +-----------+


    SELECT prenom FROM abonne WHERE id_abonne IN(
        SELECT abonne_id FROM emprunt WHERE date_rendue = "2016-12-11"
    );


    -- +-----------+
    -- | prenom    |
    -- +-----------+
    -- | Guillaume |
    -- +-----------+


    -- A SAVOIR

    -- WHERE id_abonne = abonne_id
    -- WHERE abonne_id = id_abonne
    -- WHERE id_livre = livre_id 
    -- WHERE livre_id = id_livre





    -- Afficher le nombre de livres que Guillaume a emprunté

    SELECT COUNT(*) FROM emprunt WHERE abonne_id = (
        SELECT id_abonne FROM abonne WHERE prenom = "guillaume"
    );
    

    -- 2


    SELECT COUNT(*) FROM emprunt WHERE abonne_id = (
        SELECT id_abonne FROM abonne WHERE prenom = "guillaume"
    );


    -- Afficher les infos des emprunts de l'abonné N°1
    SELECT * FROM emprunt WHERE abonne_id = 1;
    -- +------------+----------+-----------+-------------+-------------+
    -- | id_emprunt | livre_id | abonne_id | date_sortie | date_rendue |
    -- +------------+----------+-----------+-------------+-------------+
    -- |          1 |      100 |         1 | 2016-12-07  | 2016-12-11  |
    -- |          5 |      104 |         1 | 2016-12-15  | 2016-12-30  |
    -- +------------+----------+-----------+-------------+-------------+


    -- Afficher le nombre d'emprunts de l'abonné N°1
    SELECT COUNT(*) FROM emprunt WHERE abonne_id = 1;
    -- +----------+
    -- | COUNT(*) |
    -- +----------+
    -- |        2 |
    -- +----------+


    -- Afficher les infos des emprunts de l'abonné qui s'appelle Guillaume

    SELECT * FROM emprunt WHERE abonne_id = ***FOREIGN KEY***


    SELECT * FROM abonne WHERE prenom = "guillaume";
    -- +-----------+-----------+
    -- | id_abonne | prenom    |
    -- +-----------+-----------+
    -- |         1 | Guillaume |
    -- +-----------+-----------+

    SELECT id_abonne FROM abonne WHERE prenom = "guillaume";
    -- +-----------+
    -- | id_abonne |
    -- +-----------+
    -- |         1 |
    -- +-----------+
    
    SELECT * FROM emprunt WHERE abonne_id = (SELECT id_abonne FROM abonne WHERE prenom = "guillaume");


    SELECT COUNT(*) FROM emprunt WHERE abonne_id IN (
        SELECT id_abonne FROM abonne WHERE prenom = "guillaume"
    );
    -- +----------+
    -- | COUNT(*) |
    -- +----------+
    -- |        2 |
    -- +----------+


    -- Afficher le prenom des abonnés ayant déjà emprunté un livre de l'auteur Alphonse DAUDET

    SELECT id_livre FROM livre WHERE auteur = "Alphonse Daudet";
    -- +----------+
    -- | id_livre |
    -- +----------+
    -- |      103 |
    -- +----------+

    SELECT abonne_id FROM emprunt WHERE livre_id IN (103);

    -- +-----------+
    -- | abonne_id |
    -- +-----------+
    -- |         4 |
    -- +-----------+

    SELECT abonne_id FROM emprunt WHERE livre_id IN (
        SELECT id_livre FROM livre WHERE auteur = "Alphonse Daudet"
    );

    SELECT prenom FROM abonne WHERE id_abonne IN(4);
    -- +--------+
    -- | prenom |
    -- +--------+
    -- | Laura  |
    -- +--------+

    SELECT prenom FROM abonne WHERE id_abonne IN(
        SELECT abonne_id FROM emprunt WHERE livre_id IN (
            SELECT id_livre FROM livre WHERE auteur = "Alphonse Daudet"
        )
    );



-- Afficher le titre du ou des livre(s) que Chloe a emprunté 


    SELECT id_abonne FROM abonne WHERE prenom = "chloe";
    -- +-----------+
    -- | id_abonne |
    -- +-----------+
    -- |         3 |
    -- +-----------+


    SELECT livre_id FROM emprunt WHERE abonne_id IN(3);

    -- +----------+
    -- | livre_id |
    -- +----------+
    -- |      100 |
    -- |      105 |
    -- +----------+

    SELECT titre FROM livre WHERE id_livre IN(100,105);


    -- +-------------------------+
    -- | titre                   |
    -- +-------------------------+
    -- | Une vie                 |
    -- | Les Trois Mousquetaires |
    -- +-------------------------+


    SELECT titre FROM livre WHERE id_livre IN(
        SELECT livre_id FROM emprunt WHERE abonne_id IN (
            SELECT id_abonne FROM abonne WHERE prenom ="chloe"
        )
    );


-- Afficher le titre du ou des livre(s) que Chloé n'a pas emprunté 

    SELECT titre, id_livre FROM livre WHERE id_livre NOT IN(
        SELECT livre_id FROM emprunt WHERE abonne_id IN(
            SELECT id_abonne FROM abonne WHERE prenom IN ("chloe")
        )
    );

    -- +-----------------+----------+
    -- | titre           | id_livre |
    -- +-----------------+----------+
    -- | Bel-Ami         |      101 |
    -- | Le père Goriot  |      102 |
    -- | Le Petit chose  |      103 |
    -- | La Reine Margot |      104 |
    -- +-----------------+----------+


-- Afficher le prénom de l'abonné qui a emprunté le plus de livres (Benoit)

    SELECT prenom FROM abonne WHERE id_abonne = 
    (
        SELECT abonne_id FROM emprunt GROUP BY abonne_id ORDER BY COUNT(*) DESC LIMIT 1
    );



-- Afficher l'id de l'abonné qui a emprunté le plus de livres (table emprunt) 2

SELECT COUNT(*),abonne_id FROM emprunt GROUP BY abonne_id;
    -- +----------+-----------+
    -- | COUNT(*) | abonne_id |
    -- +----------+-----------+
    -- |        2 |         1 |
    -- |        3 |         2 |
    -- |        2 |         3 |
    -- |        1 |         4 |
    -- +----------+-----------+


    --2

    
    SELECT abonne_id FROM emprunt GROUP BY abonne_id ORDER BY COUNT(*) DESC LIMIT 1;
  

    -- +--------+
    -- | prenom |
    -- +--------+
    -- | Benoit |
    -- +--------+

-------------------------------------------------------------------------------------------------------
        -------------------------------------------------------------------------------------------------------
            -------------------------------------------------------------------------------------------------------
                -------------------------------------------------------------------------------------------------------
                    -------------------------------------------------------------------------------------------------------



    -- LES JOINTURES


    -- Afficher les dates de sorties et de rendues de l'abonné guillaume (prenom/date_sortie/date_rendue)

    SELECT abonne.prenom, emprunt.date_sortie, emprunt.date_rendue
    FROM abonne, emprunt
    WHERE abonne.id_abonne = emprunt.abonne_id
    AND abonne.prenom = "guillaume";


    -- +-----------+-------------+-------------+
    -- | prenom    | date_sortie | date_rendue |
    -- +-----------+-------------+-------------+
    -- | Guillaume | 2016-12-07  | 2016-12-11  |
    -- | Guillaume | 2016-12-15  | 2016-12-30  |
    -- +-----------+-------------+-------------+


    SELECT a.prenom, e.date_sortie, e.date_rendue
    FROM abonne a, emprunt e
    WHERE a.id_abonne = e.abonne_id
    AND a.prenom = "guillaume";


    -- Jointure et requête imbriquée
    -- Une jointure et une imbrication permettent de faire des requêtes sur plusieurs tables (en relation)
    -- Mais il y a une différence :
    -- imbrication n'affiche que les champs d'une seule table
    -- jointure peut afficher les champs provenant de différentes tables (fusionner)


    SELECT date_sortie, date_rendue FROM emprunt WHERE abonne_id IN(
        SELECT id_abonne FROM abonne WHERE prenom = "guillaume"
    );

    -- +-------------+-------------+
    -- | date_sortie | date_rendue |
    -- +-------------+-------------+
    -- | 2016-12-07  | 2016-12-11  |
    -- | 2016-12-15  | 2016-12-30  |
    -- +-------------+-------------+



    -- JOINTURE IMPLICITE (SANS JOIN)
    SELECT a.prenom, e.date_sortie, e.date_rendue -- les champs qu'on souhaite afficher mais il faut définir dans quelle table le champ se trouve table.champ ou alias.table
    FROM abonne a, emprunt e                       -- Informer le nom des tables, avec possibilité de lui définir un alias (unique)   syntaxe NomDeLaTable nomDeL'Alias
    WHERE a.id_abonne = e.abonne_id                -- la relation, les champs (PK-FK) en commum qui permettent la jointure     
    AND a.prenom = "guillaume";                    -- précision de la requête









    -- Afficher les mouvements des livres écrit par Alphonse DAUDET  (jointure implicite)
    -- auteur / titre / date_sortie / date_rendue


    SELECT l.auteur, l.titre, e.date_sortie, e.date_rendue
    FROM livre l, emprunt e 
    WHERE l.id_livre = e.livre_id 
    AND l.auteur = "alphonse daudet";


    -- +-----------------+----------------+-------------+-------------+
    -- | auteur          | titre          | date_sortie | date_rendue |
    -- +-----------------+----------------+-------------+-------------+
    -- | ALPHONSE DAUDET | Le Petit chose | 2016-12-12  | 2016-12-22  |
    -- +-----------------+----------------+-------------+-------------+


    -- JOINTURE EXPLICITE (AVEC JOIN)

    SELECT l.auteur, l.titre, e.date_sortie, e.date_rendue
    FROM livre l
    INNER JOIN emprunt e
    ON l.id_livre = e.livre_id
    AND l.auteur = "alphonse daudet";


    -- pas d'obligation de définir la table du champ / alias (attention si même champ dans les 2 tables)
    SELECT auteur, titre, date_sortie, date_rendue
    FROM livre 
    INNER JOIN emprunt 
    ON id_livre = livre_id
    AND auteur = "alphonse daudet";



    -- il existe différents types de jointure (INNER JOIN, RIGHT JOIN, LEFT JOIN, ......)
    -- on appelle une table avec FROM
    -- et on joint la seconde table avec le terme "... JOIN"
    -- pour définir la relation entre les 2 tables (PK = FK) on utilise le terme ON


    -- INNER JOIN, la condition est vraie entre les 2 table id_abonne = abonne_id
    -- exemple, un emprunt où abonne_id est null
    -- SELECT prenom, date_sortie, date_rendue
    -- FROM abonne
    -- INNER JOIN emprunt 
    -- ON id_abonne = abonne_id;



    
    -- qui a emprunté le livre "une vie" sur l'année 2016
    -- prenom / auteur / titre / date_sortie / date_rendue


    -- JOINTURE IMPLICITE
    SELECT a.prenom, c.auteur, c.titre, b.date_sortie, b.date_rendue
    FROM abonne a, emprunt b, livre c 
    WHERE a.id_abonne = b.abonne_id 
    AND c.id_livre = b.livre_id
    AND c.titre = "une vie"
    AND b.date_sortie LIKE "2016%";


    -- JOINTURE EXPLICITE

    SELECT a.prenom, c.auteur, c.titre, b.date_sortie, b.date_rendue
    FROM abonne a 
    INNER JOIN emprunt b
    ON a.id_abonne = b.abonne_id 
    INNER JOIN livre c 
    ON b.livre_id = c.id_livre 
    AND c.titre = "une vie"
    AND b.date_sortie LIKE "2016%";

    -- ou 

    SELECT a.prenom, c.auteur, c.titre, b.date_sortie, b.date_rendue
    FROM abonne a 
    INNER JOIN emprunt b
    INNER JOIN livre c 
    ON a.id_abonne = b.abonne_id 
    AND b.livre_id = c.id_livre 
    WHERE c.titre = "une vie" 
    AND b.date_sortie LIKE "2016%";


    -- sur la "précision" on peut définir AND ou WHERE
    -- pour rappel, il n'y a qu'un WHERE par requete



    -- requête sur 3 tables
    -- 2 jointures :
    --    - entre emprunt et abonne
    --    - entre emprunt et livre 
   

    -- +-----------+-------------------+---------+-------------+-------------+
    -- | prenom    | auteur            | titre   | date_sortie | date_rendue |
    -- +-----------+-------------------+---------+-------------+-------------+
    -- | Guillaume | GUY DE MAUPASSANT | Une vie | 2016-12-07  | 2016-12-11  |
    -- | Chloe     | GUY DE MAUPASSANT | Une vie | 2016-12-11  | 2016-12-19  |
    -- +-----------+-------------------+---------+-------------+-------------+





    -- Afficher le nombre de livres emprunté par chaque abonné
    -- prenom | nombre



    -- INDICE
    -- SELECT COUNT(*), abonne_id FROM emprunt GROUP BY abonne_id;



    -- implicite

    -- table.champ / alias non obligatoire

    SELECT a.id_abonne AS "ID de l'abonné", a.prenom, COUNT(*) AS "Nombre de livres"
    FROM emprunt e, abonne a 
    WHERE a.id_abonne = e.abonne_id 
    GROUP BY e.abonne_id 
    ORDER BY COUNT(*); 


-- +----------------+-----------+------------------+
-- | ID de l'abonn? | prenom    | Nombre de livres |
-- +----------------+-----------+------------------+
-- |              4 | Laura     |                1 |
-- |              1 | Guillaume |                2 |
-- |              3 | Chloe     |                2 |
-- |              2 | Benoit    |                3 |
-- +----------------+-----------+------------------+


--   SELECT 
--     a.prenom, 
--     b.nb
--   FROM abonne a, 

--       (SELECT abonne_id, COUNT(*) nb FROM emprunt GROUP BY abonne_id) b

--   WHERE a.id_abonne = b.abonne_id
-- ;





    -- explicite

    SELECT prenom, COUNT(*) AS 'nombre_emprunt'
    FROM emprunt
    INNER JOIN abonne
    ON id_abonne = abonne_id 
    GROUP BY abonne_id 
    ORDER BY nombre_emprunt DESC;

    
    SELECT prenom, COUNT(*) 
    FROM emprunt
    INNER JOIN abonne
    ON id_abonne = abonne_id 
    GROUP BY abonne_id 
    ORDER BY COUNT(*) DESC;

    -- L'alias, une fois créé, peut être considéré comme un "champ", Attention du coup pas de quotes

    -- +-----------+--------+
    -- | prenom    | nombre |
    -- +-----------+--------+
    -- | Benoit    |      3 |
    -- | Guillaume |      2 |
    -- | Chloe     |      2 |
    -- | Laura     |      1 |
    -- +-----------+--------+









    ------------------------------------------------------------------
    

    SELECT a.prenom, c.auteur, c.titre, b.date_sortie, b.date_rendue
    FROM abonne a, emprunt b, livre c 
    WHERE a.id_abonne = b.abonne_id 
    AND c.id_livre = b.livre_id;


-- +-----------+-------------------+-------------------------+-------------+-------------+
-- | prenom    | auteur            | titre                   | date_sortie | date_rendue |
-- +-----------+-------------------+-------------------------+-------------+-------------+
-- | Guillaume | GUY DE MAUPASSANT | Une vie                 | 2016-12-07  | 2016-12-11  |
-- | Guillaume | ALEXANDRE DUMAS   | La Reine Margot         | 2016-12-15  | 2016-12-30  |
-- | Benoit    | GUY DE MAUPASSANT | Bel-Ami                 | 2016-12-07  | 2016-12-18  |
-- | Benoit    | ALEXANDRE DUMAS   | Les Trois Mousquetaires | 2017-01-02  | 2017-01-15  |
-- | Benoit    | GUY DE MAUPASSANT | Une vie                 | 2017-02-20  | NULL        |
-- | Chloe     | GUY DE MAUPASSANT | Une vie                 | 2016-12-11  | 2016-12-19  |
-- | Chloe     | ALEXANDRE DUMAS   | Les Trois Mousquetaires | 2017-02-15  | NULL        |
-- | Laura     | ALPHONSE DAUDET   | Le Petit chose          | 2016-12-12  | 2016-12-22  |
-- +-----------+-------------------+-------------------------+-------------+-------------+


--------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------


I - Modélisation de la bdd
II - Création de la bdd
III - Insertion de données ==> requêtes
-----------------------------------------

I - Énoncé : bijouterie

MODULE 1 : utilisateur 

- Un utilisateur peut s'inscrire 
- Un utilisateur n'a qu'une seule adresse de facturation
- un utilisateur peut avoir plusieurs adresses de livraison
- un utilisateur peut écrire des commentaires sur les produits
- un utilisateur peut passer plusieurs commandes
- un utilisateur peut donner une note sur un produit 


MODULE 2 : produit

- un produit appartient à une catégorie
- un produit appartient à une marque
- un produit peut être composé de plusieurs matières (/ couleur)
- un produit appartient à un genre (valeur : homme, femme, enfant, unisexe)
- un produit peut avoir plusieurs images


MODULE 3 : Commande

- dans le panier, on a plusieurs produits, chacun avec une quantité 
- le nombre de produits dans la commande est flexible (au minimum un produit)
- une commande a un etat (en cours de traitement, expédié, livré, retour ...)
- on peut utiliser des codes promos


il reste les notes et le code promo 
--------------------------------------------------------------------------
USER
- id_user INT(11) AI PK NOT NULL
- email VARCHAR(255) NOT NULL
- mdp VARCHAR(255) NOT NULL
- roles ENUM("user", "admin", "modo")
- nom VARCHAR(255) NOT NULL
- prenom VARCHAR(255) NOT NULL
- sexe ENUM("m", "f")
- date_naissance DATETIME NOT NULL
- date_inscription DATETIME NOT NULL
- adresse_facturation_id INT(11) FK (adresse.id_adresse) NULL

(un user peut avoir plusieurs adresses mais une adresse appartient à un user)
ADRESSE
- id_adresse INT(11) AI PK NOT NULL
- user_id INT(11) FK (user.id_user) NULL
- nom VARCHAR(255) NOT NULL
- prenom VARCHAR(255) NOT NULL
- adresse VARCHAR(255) NOT NULL
- complement VARCHAR(255) NULL
- cp INT(5) NOT NULL
- ville VARCHAR(255) NOT NULL
- pays VARCHAR(255) NOT NULL
- telephone VARCHAR(255) NOT NULL
- digicode VARCHAR(255) NULL
- commentaire TEXT NULL

----------------------------------------------------------------------------------------------------------------

PRODUIT
- id_produit INT(11) AI PK NOT NULL
- nom VARCHAR(255) NOT NULL
- prix FLOAT NOT NULL
- remise INT(2) NULL
- description TEXT NULL
- quantite INT(11) NOT NULL
- genre ENUM('homme', "femme", "enfant", "unisexe")
- activation BOOLEAN
- date_creation DATETIME NOT NULL
- categorie_id INT(11) FK (categorie.id_categorie)
- marque_id INT(11) FK (marque.id_marque)

(Une catégorie peut regrouper plusieurs produits mais chaque produit appartient à une categorie)
CATEGORIE
- id_categorie INT(11) AI PK NOT NULL
- nom VARCHAR(255) NOT NULL
- description TEXT NULL


(Une marque peut regrouper plusieurs produits mais chaque produit appartient à une marque)
MARQUE
- id_marque INT(11) AI PK NOT NULL
- nom VARCHAR(255) NOT NULL
- contact VARCHAR(255) NOT NULL
- email VARCHAR(255) NOT NULL
- telephone VAzRCHAR(255) NOT NULL
- description TEXT NULL

(Une matière peut être dans plusieurs produits, mais un produit peut être composé de plusieurs matières)
MATIERE
- id_matiere INT(11) AI PK NOT NULL
- nom VARCHAR(255) NOT NULL


PRODUIT_MATIERE (table de jointure)
- produit_id INT(11) FK (produit.id_produit) NULL
- matiere_id INT(11) FK (matiere.id_matiere) NULL

(Une image n'appartient qu'à un seul produit, mais chaque produit peut avoir plusieurs images)
IMAGE
- id_image INT(11) AI PK NOT NULL
- src VARCHAR(255) NOT NULL
- alt TEXT NOT NULL
- title VARCHAR(255) NOT NULL
- produit_id INT(11) FK (produit.id_produit) NULL


(Un commentaire n'appartient qu'à un seul user, chaque user peut écrire plusieurs commentaires)
(Un commentaire n'appartient qu'à un seul produit, chaque produit peut avoir plusieurs commentaires)
COMMENTAIRE
- id_commentaire INT(11) AI PK NOT NULL
- user_id INT(11) FK (user.id_user) NULL
- produit_id INT(11) FK (produit.id_produit) NULL
- message TEXT NULL
- date_creation DATETIME NOT NULL

-----------------------------------------------------------------------------------------------------------
(Une commande est passée par un user, chaque user peut passer plusieurs commandes)
(Une commande n'a qu'une seule adresse de facturation, Cette adresse de facturation n'appartient qu'à une seule commande)
(Une commande n'a qu'une seule adresse de livraison, Cette adresse de livraison n'appartient qu'à une seule commande)
(une commande ne peut avoir qu'un seul code promo mais un code promo peut apparaître sur plusieurs commandes)
COMMANDE
- id_commande INT(11) AI PK NOT NULL
- user_id INT(11) FK (user.id_user) NULL
- date_creation DATETIME NOT NULL
- montant DOUBLE NOT NULL
- etat ENUM('en cours de traitement', 'expédié', 'livré', 'retour', 'annulé')
- adresse_livraison_commande_id INT(11) FK (adresse_livraison_commande.id_adresse_livraison_commande)
- adresse_facturation_commande_id INT(11) FK (adresse_facturation_commande.id_adresse_facturation_commande)
- code_promo_id INT(11) FK (code_promo.id_code_promo) NULL





(un détail commande appartient à la commande, et une commande peut avoir plusieurs détails commandes)
(un détail commande ne conserne qu'un seul produit, chaque produit peut se trouver dans plusieurs details commande)
DETAILS_COMMANDE
- id_details_commande INT(11) AI PK NOT NULL
- commande_id INT(11) FK (commande.id_commande) NULL
- produit_id INT(11) FK (produit.id_produit) NULL
- quantite INT(11) NOT NULL
- prix DOUBLE NOT NULL
- remise INT(2) NOT NULL






(Une adresse de livraison appartient à une commande, et une commande a une seule adresse de livraison)
ADRESSE_LIVRAISON_COMMANDE
- id_adresse_livraison_commande INT(11) AI PK NOT NULL
- nom VARCHAR(255) NOT NULL
- prenom VARCHAR(255) NOT NULL
- adresse VARCHAR(255) NOT NULL
- complement VARCHAR(255) NULL
- cp INT(5) NOT NULL
- ville VARCHAR(255) NOT NULL
- pays VARCHAR(255) NOT NULL
- telephone VARCHAR(255) NOT NULL
- digicode VARCHAR(255) NULL
- commentaire TEXT NULL
- commande_id INT(11) FK (commande.id_commande) NULL






(Une adresse de facturation appartient à une commande, et une commande a une seule adresse de facturation)
ADRESSE_FACTURATION_COMMANDE
- id_adresse_facturation_commande INT(11) AI PK NOT NULL
- nom VARCHAR(255) NOT NULL
- prenom VARCHAR(255) NOT NULL
- adresse VARCHAR(255) NOT NULL
- complement VARCHAR(255) NULL
- cp INT(5) NOT NULL
- ville VARCHAR(255) NOT NULL
- pays VARCHAR(255) NOT NULL
- telephone VARCHAR(255) NOT NULL
- commande_id INT(11) FK (commande.id_commande) NULL






----------------------------------------------------------------------------------------

CODE_PROMO
- id_code_promo INT(11) AI PK NOT NULL
- code VARCHAR(255) NOT NULL
- valeur ENUM('pourcentage', "euro")
- remise DOUBLE 

- date_boolean BOOLEAN 
- date_debut DATE NULL
- date_fin DATE NULL

- montant_boolean BOOLEAN 
- montant_min
- montant_max


- activation BOOLEAN

- image VARCHAR(255) NULL
- description TEXT NULL
- limitation INT NULL


-----------------------------------------------------
NE PAS FAIRE 
- limitation par user (de ses commandes)
- quantité du produit ?
- cumuler les codes promos 
- application sur la commande ou sur un produit
- relation user
- relation produit / categorie


--------------------------------------------------
toutes les relations sont null

conseil :

créer toutes les tables
créer tous les champs relationnelles
créer le FK

si je supprime un produit, est-ce intéressant de conserver ses images ???
nom des tables en minuscule sans accent camelcase ou _ 
